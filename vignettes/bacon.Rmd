---
title: "bacon"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{bacon}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Description
`bacon()` is a function that decomposes two-way fixed effects models into all 2x2 estimates and their weights following Goodman-Bacon (2019). It can perform the decomposition with and without time-varying covariates.

## Example: Castle Doctrine
The following example comes from Cheng and Hoekstra (2013, JHR). The authors estimate the effect of "castle doctrines," state laws that make it easier to use lethal force in self defense. The data set `castle` contains state/year level information from 2000-2010 on crime rates and whether or not the state had a castle doctrine in effect. Here we replicate the analysis on homicide rates. The key variables are :

* `state`
* `year`
* `l_homicide` log of the homicide rate
* `post` indicator for whether a castle doctrine law was in effect

Here, we perform the decomposition without time-varying controls, and make sure that the weighted average of the decomposition equals the two-way fixed effects estimate.

```{r castle, fig.width = 7}
library(bacon)

df_bacon <- bacon(l_homicide ~ post,
                  data = bacon::castle,
                  id_var = "state",
                  time_var = "year")
coef_bacon <- sum(df_bacon$estimate * df_bacon$weight)
print(paste("Weighted sum of decomposition =", round(coef_bacon, 4)))

fit_tw <- lm(l_homicide ~ post + factor(state) + factor(year), 
             data = bacon::castle)
print(paste("Two-way FE estimate =", round(fit_tw$coefficients[2], 4)))

```

Now, we plot each 2x2 estimate and its weight to see what is driving the result.

```{r plot, fig.width = 6, fig.height = 4, fig.align = 'center'}
library(ggplot2)

ggplot(df_bacon) +
  aes(x = weight, y = estimate, shape = factor(type)) +
  labs(x = "Weight", y = "Estimate", shape = "Type") +
  geom_point()
```

In this example, one estimate has almost 60 percent of the weight: states treated in 2006 vs states that are never treated.

We can also perform the decomposition including time varying controls. In this example we use population and income (both in logs). 

```{r cont}
ret_bacon <- bacon(l_homicide ~ post + l_pop + l_income, 
                   data = bacon::castle,
                   id_var = "state",
                   time_var = "year")
beta_hat_w <- ret_bacon$beta_hat_w
beta_hat_b <- weighted.mean(ret_bacon$two_by_twos$estimate, 
                            ret_bacon$two_by_twos$weight)
Omega <- ret_bacon$Omega
bacon_coef_cont <- Omega*beta_hat_w + (1 - Omega)*beta_hat_b
print(paste("Weighted sum of decomposition =", round(bacon_coef_cont, 4)))

two_way_fe_cont <- lm(l_homicide ~ post + l_pop + l_income + factor(state) + 
                        factor(year), 
                      data = bacon::castle)
two_way_fe_coef_cont <- two_way_fe_cont$coefficients["post"]
print(paste("Two way FE estimate =", round(two_way_fe_coef_cont, 4)))
```

We can also plot the decomposed between estimates and their weights.

```{r plot2, fig.width = 6, fig.height = 4, fig.align = 'center'}
df_bacon <- ret_bacon$two_by_twos
ggplot(df_bacon) +
  aes(x = weight, y = estimate) +
  labs(x = "Weight", y = "Estimate") +
  geom_point()
```
